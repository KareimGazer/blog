import{_ as i,c as t,a2 as a,o as r}from"./chunks/framework.DN5Ma_nw.js";const h=JSON.parse('{"title":"The KISS Principle","description":"","frontmatter":{"title":"The KISS Principle","subtitle":"Keep It Simple Stupid","date":"2024-07-26T00:00:00.000Z","author":"@KareimGazer","lastUpdated":true,"next":{"text":"Future Forecasting Of Time Series","link":"./Future_Forecasting_Of_Time_Series"},"prev":{"text":"Unlocking Success","link":"./Unlocking_Success.md"}},"headers":[],"relativePath":"posts/The_KISS_Principle.md","filePath":"posts/The_KISS_Principle.md","lastUpdated":1733799733000}'),o={name:"posts/The_KISS_Principle.md"};function l(n,e,s,p,c,d){return r(),t("div",null,e[0]||(e[0]=[a("<p>This principle was drawn from aircraft engineering by Kelly Johnson who stated that all systems work better if they are kept simple.</p><hr><p>Unix follows this philosophy by making each program do one thing well, and do a new job to build a fresh new program rather than complicating old programs by adding new features.</p><p>You can see this in UNIX with all the built-in utilities and tools like cat, and grep which can be combined with pipe to compose and construct new functionalities</p><p>Some UNIX design rules by Eric S. Raymond in his book “The Art of UNIX Programming” make this principle clearer.</p><ul><li>build modular programs</li><li>write readable, simple, small, transparent, robust programs</li><li>use composition</li><li>separate mechanisms from policies</li><li>make data complicated when required not the program</li><li>build on the user’s expected knowledge</li><li>avoid unnecessary output</li><li>write programs which fail in a way that is easy to diagnose</li><li>value programmer time over machine time</li><li>write abstract programs that generate code instead of writing code by hand</li><li>prototype software before polishing it</li><li>write flexible and open programs</li><li>make the programs and protocols extensible</li></ul><p>Start small and think about the layers of your project—work from general abstract concepts down to a lower level of detail. Divide complex functionality into simple functions with well-defined names. Keep doing this until all is clear and clean.</p>",7)]))}const u=i(o,[["render",l]]);export{h as __pageData,u as default};
